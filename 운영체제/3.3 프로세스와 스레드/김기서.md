# 3.3 프로세스와 스레드

**프로세스**

- 컴퓨터에서 실행되고 있는 **프로그램**
- CPU 스케줄링의 대상이 되는 작업(task)

**스레드**

- **프로세스 내** 작업의 흐름

![image](https://user-images.githubusercontent.com/81108344/206996063-db992477-5d5f-43c5-a6ae-2dc9afa311df.png)
프로그램이 메모리(RAM)에 올라가면 **프로세스**가 되는 **인스턴스화**가 일어난다.

→ 이후 운영체제의 CPU 스케줄러에 따라 CPU가 프로세스를 실행한다.

- 프로그램이란 0과 1로 된, 컴퓨터에게 어떤 동작을 실행하라는 **명령어**들의 집합이다. 이 프로그램이란 것을 실행시키게 되면 프로그램이라 불리는 명령어들이 **메인 메모리**(RAM 램)에 배치된다. 이 상태를 **프로세스**라고 부른다.
- 이 배치된 명령어들을 하나씩 순서대로, 혹은 지정된 주소에 있는 명령어들을 읽어와서 **CPU**에서 **계산 및 처리**를 하게 되고 그 명령어대로 CPU가 다른 컴퓨터 **자원들의 동작, 수행을 명령**한다. 그리고 이 0과 1로 이루어진 명령어 들을 **기계어**라고 한다.

# 3.3.1 프로세스와 컴파일 과정

**컴파일 언어의 컴파일 과정**
![image](https://user-images.githubusercontent.com/81108344/206996071-80a9c858-5a96-45ca-bee4-c803e9464fc0.png)

### 1. 전처리

- 소스 코드의 주석을 제거하고 #include 등의 헤더 파일을 병합하여 매크로를 치환한다.

### 2. 컴파일러

- 오류 처리, 코드 최적화 작업을 하며 **어셈블리어**로 변환한다.

### 3. 어셈블러

- 어셈블리어를 **목적 코드(object code)**로 변환한다.
- 확장자는 운영체제마다 다르며 각 운영체제에 맞는 확장자 파일이 생성된다.

⇒ 컴퓨터는 오직 기계어(0과 1로 이루어진)만 이해할 수 있기 때문에 **어셈블리어를** 0과 1의 집합인     기계어로 바꿔주는 역할을 하는 프로그램이 바로 이 **어셈블러**다.

### 4. 링커

- 프로그램 내에 있는 라이브러리 함수 또는 다른 파일과 목적 코드를 결합해 실행 파일을 만든다.
- 실행 파일은 .exe 또는 .out이라는 확장자를 갖는다.

⇒ 어셈블러가 생성한 목적 파일들을 결합하여 하나의 실행 파일로 만드는 작업을 해준다.

![image](https://user-images.githubusercontent.com/81108344/206996077-03ddf942-38f5-4fe9-9124-0b5693f83a00.png)
**정적 라이브러리와 동적 라이브러리**

정적 라이브러리: 프로그램 빌드 시 라이브러리가 제공하는 모든 코드를 **실행 파일**에 넣는 방식

→ 시스템 환경 등 외부 의존도가 낮으나 코드 중복, 메모리 효율성 등의 단점도 존재한다.

동적 라이브러리: 프로그램 실행 시 필요할 때만 **DLL** 이라는 함수 정보를 통해 참조하는 방식

→ 메모리 효율성은 높으나 외부 의존도가 높아진다는 단점이 존재한다.

**DLL(Dynamic Link Library)**이란?

- 동적 링크라고 하며 실행 파일에서 해당 라이브러리의 기능을 사용 시에만, 라이브러리 파일을 참조하여(혹은 다운로드받아) 기능을 호출한다.
- 정적 링크와는 다르게 컴파일 시점에 실행 파일에 함수를 복사하지 않고, 함수의 위치정보만 갖고 그 함수를 호출할 수 있게 한다.

# 3.3.2 프로세스의 상태

### 생성 상태

- 프로세스가 생성된 상태
- `PCB`가 할당된다.
- fork(), exec() 함수를 통해 생성된다.

  **fork()**

    - 부모 프로세스의 주소 공간을 그대로 복사하며, 새로운 자식 프로세스를 생성하지 않는 함수
    - fork() 시스템 호출은 새로운 프로세스를 위한 메모리를 할당한다. 그리고 fork( ) 를 호출한 프로세스를 새로운 공간으로 모두 복사한다.
    - 이후 원래 프로세스는 원래 프로세스대로 실행되고, fork를 이용해서 생성된 프로세스도 fork( ) 시스템 콜이 수행된 라인의 다음 라인부터 실행된다.

  **exec()**

    - 새롭게 프로세스를 생성하는 함수
    - exec 시스템 콜은 fork( ) 처럼 새로운 프로세스를 위한 메모리를 할당하지 않고, exec( )를 호출한 프로세스의 메모리에 새로운 프로세스의 코드를 덮어씌워 버린다.
    - 따라서, exec를 호출한 프로세스가 아닌 exec에 의해 호출된 프로세스만 메모리에 남게 된다.

```java
Process proc = Runtime.getRuntime().exec("java -jar A.jar");
```

### 대기 상태

- 메모리 공간이 충분하면 메모리를 할당받고 아니면 그대로 대기하고 있으며 CPU 스케줄러로부터 CPU 소유권이 넘어오기를 기다리는 상태

### 대기 중단 상태

- 메모리 부족으로 일시 중단된 상태

### 실행 상태

- CPU 소유권과 메모리를 할당받고 인스트럭션을 수행 중인 상태

### 중단 상태

- 어떤 이벤트가 발생한 이후 기다리며 프로세스가 차단된 상태
- I/O 디바이스에 의한 **인터럽트**로 이런 현상이 많이 발생한다.
- ex) 프린트 인쇄 버튼을 눌렀을 때 프로세스가 잠깐 멈춘 듯할 때

### 일시 중단 상태

- 중단 상태에서 프로세스가 실행되려고 했으나 메모리 부족으로 일시 중단된 상태

### 종료 상태

- 메모리와 CPU 소유권을 모두 반납하고 가는 상태
- 부모 프로세스가 강제로 종료시키는 **비자발적 종료**

# 3.3.3 프로세스의 메모리 구조

- 운영체제는 프로세스에 적절한 메모리를 할당하는데 다음 구조를 기반으로 할당하게 된다.



![image](https://user-images.githubusercontent.com/81108344/206996088-58360a5c-e36b-4566-8057-54c26039bceb.png)
### 스택

- **지역변수, 매개변수, 함수**가 저장되며 **컴파일** 시에 크기가 결정되는 **동적**인 특징을 갖는다.
- 함수 호출 시 할당되고 함수 반환 시 소멸되며 **잠시 사용되었다가 사라지는 데이터**를 저장하는 영역이다.
- 스택 영역은 동적으로 크기가 늘어날 수 있으므로 힙 영역과 겹치지 않기 위해 힙과 스택 사이에 공간을 비워 놓는다.

### 힙

- 동적 할당할 때 사용되며 **런타임** 시 크기가 결정된다.
- ex) 벡터와 같은 동적 배열은 힙에 할당된다.
- 자바에서는 객체가 heap영역에 생성되고 GC에 의해 정리된다.
- stack에서 person 변수를 할당하면 person이 가리키는 heap 영역의 임의의 공간부터 원하는 크기만큼 할당해 사용하게 된다.

### 데이터 영역

- 전역변수, 정적변수가 저장된다.
- **BSS 영역**과 **Data 영역**으로 나뉘며, BSS 영역은 초기화 되지 않은 변수들이 0으로 초기화되어 저장된다. 초기화 된 전역변수는 Data 영역에 저장된다.

### 코드 영역

- 프로그램에 내장된 **소스코드**가 들어가는 영역
- CPU는 이 영역에서 명령어를 하나씩 가져와 처리한다.
- 수정 불가능한 기계어로 저장되어있다.

## 3.3.4 PCB

### PCB(Process Control Block)란

- 운영체제에서 프로세스에 대한 **메타데이터**를 저장한 데이터
- 프로세스가 생성되면 운영체제는 해당 PCB를 생성한다.
- 프로세스의 중요 정보가 포함되므로 커널 스택의 가장 앞부분에서 관리된다.

**PCB의 구조**

- PCB는 다음과 같은 정보로 이루어져 있다.
    - 프로세스 스케줄링 상태: 준비, 일시중단 등 프로세스가 CPU에 대한 소유권을 얻은 이후의 상태
    - 프로세스 ID
    - 프로세스 권한: 컴퓨터 자원, I/O 디바이스에 대한 권한 정보
    - CPU 레지스터: 프로세스를 실행하기 위해 저장해야 할 레지스터에 대한 정보
    - CPU 스케줄링 정보: CPU 스케줄러에 의해 중단된 시간 등에 대한 정보
    - 계정 정보: 프로세스 실행에 사용된 CPU 사용량, 실행한 유저의 정보
    - I/O 상태 정보: 프로세스에 할당된 I/O 디바이스 목록

## 컨텍스트 스위칭(context switching)

- PCB를 교환하는 과정
- 한 프로세스에 할당된 시간이 끝나거나 인터럽트에 의해 발생한다.

**컨텍스트란?**

CPU가 해당 프로세스를 실행하기 위한 해당 프로세스의 정보들이다.

컨텍스트는 프로세스의 **PCB(Process Control Block)**에 저장된다.

CPU가 어떤 프로세스를 실행하고 있는 상태에서 인터럽트에 의해 다음 우선 순위를 가진 프로세스가 실행되어야 할 때 기존의 프로세스 정보들은 PCB에 저장하고 다음 프로세스의 정보를 PCB에서 가져와 교체하는 작업을 **컨텍스트 스위칭**이라 한다.

### 비용

![image](https://user-images.githubusercontent.com/81108344/206996097-d02d368a-6d14-4ba7-810c-c5b852146811.png)

### 유휴 시간

- 위 그림을 보면 프로세스 A가 실행 중인 상태에서 유휴 상태가 될 때 프로세스 B가 곧바로 실행되지 못한다.
- 그 이유는 프로세스 A의 상태를 PCB에 저장하고 프로세스 B 상태를 PCB에서 가져와야 하기 때문이다.
- 그런데, 이 과정에서 PCB를 저장하고 가져올 때 CPU는 아무런 일도 하지 못하게 된다.
  이처럼 아무런 일도 하지 못하게 되는 상황이 잦을수록 성능 저하로 이어진다.

### 캐시 미스

- 캐시에는 현재 실행중인 프로세스의 data가 들어있다.
- 컨텍스트 스위칭이 발생하면 이 정보들이 쓸모없어질 확률이 높으므로 캐시를 비워버린다.
- 컨텍스트 스위칭 직후에는 캐시가 비어있으므로 계속해서 캐시미스가 발생한다.
- 메모리로 가서 캐시로 데이터를 올리고 CPU로 가져오는 횟수(메모리 접근 횟수)가 증가하여 오버헤드가 커진다.

### 스레드에서의 컨텍스트 스위칭

- 스택 영역을 제외한 모든 메모리를 공유하므로 스레드 컨텍스트 스위칭이 비용과 시간 둘다 적게 소모된다.
- 멀티 쓰레드 > 멀티 프로세스 ?


# 3.3.5 멀티프로세싱

멀티 프로세싱이란 여러개의 프로세스를 통해 동시에 두 가지 이상의 일을 수행할 수 있는 것을 말한다.

하나 이상의 일을 **병렬 처리**할 수 있으며 특정 프로세스에 문제가 발생되더라도 **다른 프로세스**를 이용할 수 있어 신뢰성이 높다.

![image](https://user-images.githubusercontent.com/81108344/210355869-66734496-256c-40cb-8b72-4a0425581924.png)

## IPC(Inter Process Communication)

- 멀티 프로세스는 프로세스끼리 **데이터를 공유**할 수 있다.
- **공유 메모리, 파일, 소켓, 익명 파이프, 명명  파이프, 메시지 큐** 등
- 메모리가 완전히 공유되는 스레드보다는 속도가 떨어진다.

### 공유 메모리

- 여러 프로세스에 동일한 메모리 블록에 대한 접근 권한이 부여되어, 프로세스 간 통신할 수 있도록 공유 버퍼를 생성하는 것
- 기본적으로 각 프로세스의 메모리를 다른 프로세스가 접근할 수 없지만 **공유 메모리**를 사용하면 여러 프로세스가 **하나의 메모리를 공유할 수 있다**.
- 메모리 자체를 공유하므로 불필요한 데이터 복사 X, 단 동기화가 필요하다.
- RAM도 하드웨어 관점에서는 공유메모리에 속한다.

### 파일

- 디스크에 저장된 데이터 또는 파일 서버에서 제공한 데이터

### 소켓

- 동일한 컴퓨터의 다른 프로세스나 네트워크의 다른 컴퓨터로 네트워크 인터페이스를 통해 전송하는 데이터
- TCP, UDP

### 익명 파이프

- 프로세스 간에 **FIFO 방식**으로 읽히는 임시공간인 파이프를 기반으로 데이터를 주고받는다.
- 단방향 방식의 읽기 전용, 쓰기 전용 파이프를 만들어서 작동하는 방식
- 다른 네트워크상에서는 사용이 불가능하며 부모 - 자식 프로세스 간에만 사용할 수 있다.

![image](https://user-images.githubusercontent.com/81108344/210355944-047a1f58-439a-4c2d-ab50-4953f3b6a808.png)

### 명명된 파이프

- **파이프 서버**와 하나 이상의 **파이프 클라이언트** 간의 통신을 위한 단방향 또는 이중 파이프
- 클라이언트/서버 통신을 위한 별도의 파이프를 제공하며, 여러 파이프를 동시에 사용 할 수 있다.
- 컴퓨터의 프로세스끼리 또는 **다른 네트워크상의 컴퓨터**와도 통신할 수 있다.

### 메시지 큐

- 메시지를 큐(queue) 데이터 구조 형태로 관리하는 것
- 커널의 전역변수 형태 등 **커널**에서 전역적으로 관리된다.
- 사용 방법이 직관적이고 간단해서 간단하게 메시지 큐에 접근할 수 있다.
- **공유 메모리**를 통해 IPC를 구현할 때 쓰기/읽기 빈도가 높으면 동기화 때문에 기능 구현에 어려움을 겪는데 이때 대안으로 **메시지 큐**를 사용하기도 한다.

# 3.3.6 스레드와 멀티스레딩

## 스레드

- 프로세스의 실행 가능한 가장 작은 단위
- 프로세스는 여러 스레드를 가질 수 있다.


![image](https://user-images.githubusercontent.com/81108344/210355970-aed3eb9c-482e-4dc1-895e-d3667679657f.png)

- **프로세스**는 코드, 데이터, 스택, 힙을 **각각 생성**하지만 **스레드**는 코드, 데이터, 힙은 스레드끼리 **서로 공유**한다.

## 멀티스레딩

- 프로세스 내 작업을 여러개의 스레드로 처리하는 기법
- 스레드 간 서로 자원을 공유하므로 효율성이 높다.
- 새 프로세스를 생성하는 대신 스레드를 사용하는 웹서버는 훨씬 적은 리소스를 소비한다.
- 한 스레드에 문제가 생기면 다른 스레드에도 영향을 끼쳐 스레드로 이루어진 프로세스에 영향을 줄 수 있다.

# 3.3.7 공유 자원과 임계 영역

## 공유 자원

- 시스템 안에서 각 프로세스, 스레드가 함께 접근할 수 있는 자원이나 변수
  ex) 모니터, 프린터, 메모리, 파일, 데이터
- 이 공유 자원을 두 개 이상의 프로세스가 동시에 읽거나 쓰는 상황을 **경쟁상태**라고 한다.

![image](https://user-images.githubusercontent.com/81108344/210356062-0d481c22-8732-4640-aa6e-91bcaa3919e2.png)
### 임계 영역

- 둘 이상의 프로세스, 스레드가 공유 자원에 접근할 때 순서 등의 이유로 결과가 달라지는 코드영역
- 해결 방법으로는 **뮤텍스, 세마포어, 모니터**가 있다.
- 이 방법들은 모두 **상호 배제, 한정 대기, 융통성**이란 조건을 만족한다.
  - **상호 배제**: 한 프로세스가 임계 영역에 들어갔을 때 다른 프로세스는 들어갈 수 없다.
  - **한정 대기**: 특정 프로세스가 영원히 임계 영역에 들어가지 못하면 안 된다.
  - **융통성**: 한 프로세스가 다른 프로세스의 일을 방해해서는 안 된다.


### 뮤텍스(mutex)

- 프로세스나 스레드가 공유 자원을 lock()을 통해 잠금 설정하고 사용한 후 unlock()을 통해 잠금 해제하는 객체
- 뮤텍스는 잠금/잠금 해제라는 상태만을 가진다.

### 세마포어

- 일반화된 뮤텍스로 간단한 정수 값과 두 가지 함수(wait, signal)로 공유 자원에 대한 접근을 처리한다.
- `wait()`은 자신의 차례가 올 때까지 기다리는 함수이며, `signal()`은 다음 프로세스로 순서를 넘겨주는 함수다.
- 프로세스나 스레드가 공유 자원에 접근하면 세마포어에서 wait() 작업을 수행하고, 공유 자원을 해제하는 순간 세마포어에서 signal() 작업을 수행한다.

**바이너리 세마포어**

- 0과 1의 두 가지 값만 가질 수 있는 세마포어
- 뮤텍스와 유사하나, 뮤텍스는 잠금을 기반으로 상호배제가 일어나는 `잠금 메커니즘`이고 세마포어는 신호를 기반으로 상호 배제가 일어나는 `신호 메커니즘`이다.

**카운팅 세마포어**

- 여러 값을 가질 수 있는 세마포어로, 여러 자원에 대한 접근을 제어하는 데 사용된다.

### 모니터

- 둘 이상의 스레드나 프로세스가 공유 자원에 안전하게 접근하도록 **공유 자원을 숨기고** 해당 접근에 대해 **인터페이스만** 제공한다.
- 세마포어보다 구현이 쉬우며 상호 배제는 자동으로 구현된다.
  - 모니터 큐를 통해 공유 자원에 대한 작업들을 순차적으로 처리할 수 있다.

![image](https://user-images.githubusercontent.com/81108344/210356126-802c401a-005a-4eb5-b8f2-6fedf42ca945.png)
- 모니터의 구성요소: mutex(critical section에서 상호배제를 보장한다), condition variable
- mutex 락을 취득하지 못한 쓰레드는 큐에 들어가 대기상태가 된다.
- mutex 락을 취득한 쓰레드가 작업을 마치면 큐에 대기상태로 있던 쓰레드 중 하나가 실행된다.

- condition variable: mutex와 마찬가지로 대기 큐를 가지며 조건이 충족되기를 기다리는 스레드들이 대기 상태로 머무는 곳이다.
  - 주요 동작: wait(), signal(), broadcast()

# 3.3.8 교착 상태

- 두 개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태

### 원인

- 상호 배제: 한 프로세스가 자원을 독점하고 있으며 다른 프로세스는 접근이 불가능하다.
- 점유 대기: 특정 프로세스가 점유한 자원들 다른 프로세스가 요청하는 상태
- 비선점: 다른 프로세스의 자원을 강제적으로 가져올 수 없다.
- 환형 대기: 프로세스 A는 프로세스 B의 자원을 요구하고, 프로세스 B는 프로세스 A의 자원을 요구하는 등 서로가 서로의 자원을 요구하는 상황

### 교착 상태의 해결 방법

- 자원 할당 시 애초에 조건이 성립되지 않도록 설계
- `은행원 알고리즘`을 사용한다.
  - 교착 상태 가능성이 없을 때만 자원을 할당하며, 프로세스당 요청할 자원들의 최대치를 통해 자원 할당 가능 여부를 파악한다.
- 교착 상태가 발생하면 사이클이 있는지 검사하며 이에 관련된 프로세스를 한 개씩 지운다.
- 현대 운영체제는 교착 상태 발생 시 사용자가 작업을 종료한다.