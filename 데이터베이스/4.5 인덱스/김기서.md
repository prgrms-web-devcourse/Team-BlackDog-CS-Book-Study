# 4.5 인덱스

## 4.5.1 인덱스의 필요성

- 데이터를 빠르게 찾을 수 있는 하나의 장치
- 책 뒤의 `찾아보기`

## 4.5.2 B(Balanced)-트리

- 인덱스는 B-트리 자료구조로 이루어져 있다.

### 구조 및 특성(MySQL)

- 구조
    - 최상위에 하나의 루트 노드가 존재하고 그 하위에 자식 노드가 붙어있는 형태
    - 가장 하위에 있는 노드를 리프 노드, 중간의 노드를 브랜치 노드라고 한다.
- 특성
    - 인덱스의 리프 노드는 항상 실제 **데이터 레코드를 찾아가기 위한 주소값**을 가지고 있다.
        - 대부분 RDBMS의 데이터 파일에서 레코드는 임의의 순서로 저장된다.
        - 단, InnoDB 테이블의 레코드는 클러스터되어 디스크에 저장되므로 프라이머리 키 순으로 정렬되어 저장된다.
    - InnoDB 테이블에서 인덱스를 통해 레코드를 읽을 때는 데이터 파일을 바로 찾아가지 못한다.
        - 인덱스에 저장된 프라이머리 키 값을 이용해 프라이머리 키 인덱스(데이터 파일)를 한번 더 검색한 후, 프라이머리 키 인덱스의 리프 페이지에 저장된 레코드를 읽는다.

### 트리의 대수확장성

- 인덱스 트리는 리프 노드 수에 비해 매우 느리게 성장한다.
- depth가 10일 때, 약 100만개의 레코드를 검색할 수 있다.

## 4.5.3 인덱스 만드는 방법

### MySQL

- 클러스터형 인덱스(PK)
    - primary key 옵션으로 기본키를 만들면 클러스터형 인덱스가 생성된다.
    - 기본키가 아닌 컬럼에도 unique not null 옵션을 붙이는 경우 생성됨
- 세컨더리 인덱스
    - `create index...` 명령어를 기반으로 생성되는 인덱스
    - 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성해야 하는 인덱스다.

### MongoDB

- 도큐먼트를 만들면 자동으로 `ObjectID`가 형성되며, 해당 키가 기본키로 설정된다.
- 세컨더리키도 부가적으로 설정해서 기본키와 함께 쓰는 복합 인덱스를 설정할 수 있다.

## 4.5.4 인덱스 최적화 기법

### 인덱스는 비용이다

- 인덱스 트리를 탐색하고 데이터 테이블을 탐색하므로 관련 읽기 비용이 들게된다.
- B트리 높이를 균형있게 조절하는 비용도 필요하다.
- 일반적인 DBMS의 옵티마이저는 인덱스를 통해 레코드를 1건 읽는 것이 테이블에서 직접 읽는 것보다 **4~5배** 정도 비용이 더 많이 드는 작업으로 예측한다.
    - 인덱스를 통해 읽을 레코드의 건수가 전체 테이블 레코드의 20~25%를 넘어서면 테이블을 직접 읽은 뒤 필터링하는 방식이 효율적이다.
    - 100만 건의 레코드가 저장된 테이블에서 50만 건을 읽는 쿼리가 있다면, 인덱스를 통해 50만 건만 읽어오는 것 보다, 전체 테이블을 읽은 뒤 필요없는 50만 건을 버리는 것이 더 효율적이다.
    - 만약 50만 건을 강제로 인덱스를 사용하도록 힌트를 추가해도, 옵티마이저는 기본적으로 **힌트를 무시**하고 테이블을 직접 읽는 방식으로 처리한다

### 항상 테스팅하라

- `explain() 함수`를 통해 인덱스를 걸고, 쿼리를 날린 뒤 걸리는 시간을 테스팅해야 한다.

### 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다

- 여러 필드를 기반으로 조회할 때 복합 인덱스를 생성하는데, 이 인덱스를 생성할 때는 위와 같은 순서를 지킨다.
- 카디널리티(유니크한 값의 정도)가 높은 컬럼을 인덱스로 잡아야 해당 인덱스로 많은 부분들을 걸러낼 수 있다. —> 주민번호 or 계좌번호인 경우 인덱스를 통해 데이터의 대부분을 걸러낼 수 있음.