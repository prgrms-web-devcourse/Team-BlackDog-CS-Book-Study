# ERD와 정규화



ERD : (Entity Relationship Diagram) : 데이터베이스를 구축할 때 뼈대를 세우듯이 설계하는 것이며, 릴레이션(테이블) 간의 관계들을 정의한것이다. 이 다이어그램을 기반으로 테이블을 생성하고 데이터베이스를 구축한다.

<img src ="https://blog.kakaocdn.net/dn/bFKA9t/btrR1fS7n6K/5hg9rV0gniu0O9NcKQKmp0/img.png" width=600 height=700>



### ERD의 중요성

ERD는 시스템의 요구사항을 기반으로 작성되며, 이 ERD를 기반으로 데이터베이스를 구축한다.  
데이터베이스를 구축한 이후에도 디버깅 또는 비즈니스 프로세스 재설계가 필요한 경우에 수정을 하기도 하며 설계도 역할을 담당한다.  
하지만 ERD는 관계형 구조로 표현할 수 있는 데이터를 구성하는데는 유용하지만, 비정형 데이터를 충분히 표현할 수 없다는 단점이 있다.

> 비정형 데이터 : 비구조화 데이터. 미리 정의된 데이터 모델이 없거나 미리 정의된 방식으로 정리되지 않은 정보를 말한다. 

  


### ERD 작성 방법

#### 1. ERD의 표기법

#### 1-1 개체(Entity) - 사각형으로 표시

- 사물 또는 사건으로 정의
- 사각형으로 표기
- 사각형 안에는 개체명을 기입하며, 단수형으로 명명
- 가능한 대문자로 개체명을 사용
- 유일한 단어로 사용

#### 1-2 속성(Attribute) - 동그라미로 표시

- 개체가 가지고 있는 요소 또는 성질
- 속성은 선으로 연결된 동그라미로 표기
- 속성명은 단수형으로 명명
- 속성명은 개체명과 동일한 명칭으로 사용하지 않음
- 속성 값이 null 인지 고려

#### 1-3 관계(Relationship) - 마름모형으로 표시

- 관계 표시는 대부분 마름모형으로 표기하지만 표기법에 따라 다양하게 표현 가능
- 1:1, 1:n, n:m 등을 파악해야함

이 표기법들을 사용하여

1. 모든 엔티티들을 정의

   - 엔티티는 특정 다이어그램에서 한 번만 나타나야한다

   - 모든 엔티티에 대해 사각형을 만들고 이름을 적절하게 지정한다


2. 엔티티 간 관계들을 정의
   - 선을 사용하여 연결하고 관계를 설명하는 중간에 다이아몬드를 추가


3. 속성들을 추가

   - 쉽게 이해할 수 있도록 의미있는 속성이름을 지정  

       




## 정규화

정규화는 이상현상이 있는 릴레이션(테이블)을 분해하여 이상현상을 없애는 과정이다. 이상현상이 존재하는 릴레이션을 분해하여 여러 개의 릴레이션을 생성하게 된다. 이를 단계별로 구분하여 정규형이 높아질수록 이상현상은 줄어들게 된다.

- **Attribute 간의 종속성****으로 인한 이상현상이 발생하는 릴레이션을 분해하여 재디자인함으로써 이상현상을 없애는 과정**
- **데이터의 중복 방지, 무결성을 충족하기 위해 데이터베이스를 설계하는 방법**

정규화에는 아래와 같은 3가지 원칙이 있다.  


   

**1. 정보의 무손실** : 분해된 릴레이션이 표현하는 정보는 분해되기 전의 정보를 모두 포함해야 한다.

**2. 최소 데이터 중복** : 이상 현상을 제거, 데이터 중복을 최소화

**3. 분리의 원칙** : 하나의 독립된 관계성은 하나의 독립된 릴레이션으로 분리해서 표현

   


정규화의 **장점**

* 각종 이상 현상들을 해결할 수 있다. 

* 새로운 속성의 추가로 인해 DB 구조를 확장하는 경우, 구조의 변경을 최소화할 수 있다. 따라서 DB와 연동된 응용프로그램에 최소한의 영향만을 미쳐 응용프로그램의 생명을 연장시킨다. 

* 정규화된 릴레이션 간의 관계가 현실 세계에서의 개념들간의 관계를 잘 보여준다. 

   


**정규화의 단점**

- 릴레이션의 분해로 인해 릴레이션 간의 JOIN 연산이 많아진다.
- 질의에 대한 응답 시간이 느려질 **수도** 있다. 데이터의 중복 속성을 제거하고 결정자에 의해 동일한 의미의 일반 속성이 하나의 테이블로 집약되므로 한 테이블의 데이터 용량이 최소화되는 효과가 있다. 
- 따라서 데이터를 처리할 때 속도가 빨라질 수도 있고 느려질 수도 있다.
- 만약 조인이 많이 발생하여 성능 저하가 나타나면 **반정규화(De-normalization)**를 적용할 수도 있다.



#### 정규화의 종류

1정규화, 2정규화, 3정규화, BCNF 정규화(BCNF (Boyce-Codd Normal Form), 보이스 코드), 4정규화.. 5정규화...  

>  보통 정규화는 BCNF 까지만 하는 경우가 많다. 그 이상 정규화를 하면 정규화의 단점이 나타날 수도 있다.

  


---

### 이상현상 (Anomaly)

**이상현상**이란, **테이블 내의 데이터들이 불필요하게 중복되어 테이블을 조작할 때 발생되는 데이터 불일치 현상**이다.

테이블을 잘못 설계하여 삽입, 삭제, 갱신할 때 오류가 발생하게 되는 것이다.   
이상현상에는 크게 3가지 이상현상이 있으며, 정규화를 통해서 이상현상들을 해결할 수 있다. 

 

**- 삽입 이상 (insertion anomaly)** : 원하지 않는 자료가 삽입된다든지, key가 없어 삽입하지 못하는(불필요한 데이터를 추가해야 삽입할 수 있음) 문제점

**- 삭제 이상 (deletion anomaly)** : 하나의 자료만 삭제하고 싶지만, 그 자료가 포함된 튜플 전체가 삭제됨으로 원하지 않는 정보 손실이 발생하는 문제점

**- 갱신 이상 (update anomaly)** : 일부만 변경하여 데이터가 불일치하는 모순, 또는 중복되는 튜플이 존재하게 되는 문제점. 

---

### 함수 종속성 (Functional Dependency)

> 함수 종속이란 데이터베이스의 릴레이션(relation)에서 두 개의 속성(attribute) 집합 간 제약의 일종이다.

어떤 릴레이션 R에서, X와 Y를 각각 R의 속성(attribute) 집합의 부분 집합이라 하자.   
속성(attribute) X의 값 각각에 대해 시간에 관계없이 항상 속성(attribute) Y의 값이 오직 하나만 연관되어 있을 때 Y는 X에 함수 종속이라 하고, X → Y라고 표기한다.   



다시 말해, **R 내의 속성(attribute) 의 집합 X와 역시 R 내에 있는 또 다른 속성(attribute) 의 집합 Y에 대해, 각각의 X 값에 대해 최대 한 개의 Y 값에 연관되어 있을 때, 속성(attribute) 의 집합 X를 함수 결정(to functionally determine)하다고 한다.**

> X를 결정자(determinant set)이라 하고, Y를 종속자(dependent attribute)라고 한다



#### 1. 완전 함수 종속 (Full Functional Dependency)

> 종속자가 기본키에만 종속되며, 기본키가 여러 속성으로 구성되어 있을경우 기본키를 구성하는 모든 속성이 포함된 기본키의 부분집합에 종속된 경우



#### 2. 부분 함수 종속 (Partial Functional Dependency)

> 릴레이션에서 종속자가 기본키가 아닌 다른 속성에 종속되거나, 기본키가 여러 속성으로 구성되어 있을경우 기본키를 구성하는 속성 중 일부만 종속된 경우.



#### 3. 이행 함수 종속 (Transitive Functional Dependecy)

> 릴레이션에서 X, Y, Z라는 3 개의 속성이 있을 때 X→Y, Y→Z 이란 종속 관계가 있을 경우, X→Z가 성립될 때 이행적 함수 종속이라고 합니다. 즉, X를 알면 Y를 알고 그를 통해 Z를 알 수 있는 경우.



#### 4. 결정자 함수 종속 (Boyce-codd Normalization)

> 함수 종속의 결정자가 후보키가 아닌 경우.



---

### 정규화의 원칙

1. 같은 의미를 표현하는 릴레이션이지만 좀 더 좋은 구조로 만들어야 한다. 
2. 자료의 중복성은 감소해야 한다.
3. 독립적인 관계는 별개의 릴레이션으로 표현해야 한다
4. 각각의 릴레이션은 독립적인 표현이 가능해야 한다.

  


---



### 1정규화 (1NF) 

애트리뷰트(열)의 도메인(속성)이 오직 원자 값만을 표현하고 튜플의 모든 애트리뷰트가 도메인에 속하는 하나의 값을 가져야 한다.

모든 도메인이 더이상 분해될 수 없는 원자 값(atomic value)로 구성되어야 한다. 

* 한 개의 기본키에 대해 두 개 이상의 값을 가지는 반복 집합이 있어서는 안된다.



제1 정규형은 다음과 같은 규칙들을 만족해야 한다.

> 1. 각 컬럼이 하나의 속성만을 가져야 한다.
> 2. 하나의 컬럼은 같은 종류나 타입(type)의 값을 가져야 한다.
> 3. 각 컬럼이 유일한(unique) 이름을 가져야 한다.
> 4. 컬럼의 순서가 상관없어야 한다.



| 유저번호 | 유저 ID | 수강명                        | 성취도   |
| -------- | ------- | ----------------------------- | -------- |
| 1        | 영수    | 자바 코딩테스트, 백엔드 특강  | 90%, 10% |
| 2        | 별이    | 데브코스 특강, 우아한테크코스 | 90%, 90% |



* 수강명과 성취도 컬럼이 2개 이상의 속성을 가지므로 다음과 같이 분리해야 한다. 



| 유저번호 | 유저 ID | 수강명          | 성취도 |
| -------- | ------- | --------------- | ------ |
| 1        | 영수    | 자바 코딩테스트 | 90     |
| 1        | 영수    | 백엔드 특강     | 10     |
| 2        | 별이    | 데브코스 특강   | 90     |
| 2        | 별이    | 우아한테크코스  | 90     |





---

### 2 정규화 (2NF)

제2 정규형은 다음과 같은 규칙을 만족해야 한다.

> 1. 1정규형을 만족해야 한다.
> 2. 모든 컬럼이칼럼이 부분적 종속(Partial Dependency)이 없어야 한다. == 모든 칼럼이 완전 함수 종속을 만족해야 한다.



* 부분적 종속이란 기본키 중에 특정 컬럼에만 종속되는 것이다. 

* 완전 함수 종속이란 기본키의 부분집합이 결정자가 되어선 안된다는 것이다. 



| 유저번호 | 유저 ID | 수강명          | 성취도 |
| -------- | ------- | --------------- | ------ |
| 1        | 영수    | 자바 코딩테스트 | 90     |
| 1        | 영수    | 백엔드 특강     | 10     |
| 2        | 별이    | 데브코스 특강   | 90     |
| 2        | 별이    | 우아한테크코스  | 90     |



* 수강명, 성취도가 {유저번호, 유저ID}에 완전 종속되어야 한다 
* 따라서 다음처럼 분리되어야 한다. 



| 유저번호 | 유저 ID |
| -------- | ------- |
| 1        | 영수    |
| 2        | 별이    |

  


| 유저 ID | 수강명          | 성취도 |
| ------- | --------------- | ------ |
| 영수    | 자바 코딩테스트 | 90     |
| 영수    | 백엔드 특강     | 10     |
| 별이    | 데브코스 특강   | 90     |
| 별이    | 우아한테크코스  | 90     |



* 이 때 주의할점은 릴레이션을 분해할 때 동등한 릴레이션으로 분해해야 하고 정보 손실이 발생하지 않는 무손실 분해로 분해되어야 한다. 



---

### 3 정규화 (3NF)



제3 정규형은 다음과 같은 규칙을 만족해야 한다.

> 1. 2 정규형을 만족해야 한다.
> 2. 기본키를 제외한 속성들 간의 이행 종속성 (Transitive Dependency)이 없어야 한다.
>
> > 이행 종속성이란 A->B, B->C 일 때 A->C 가 성립하면 이행 종속이라고 한다. 





| 유저 ID | 등급   | 할인율 |
| ------- | ------ | ------ |
| 영수    | 챌린저 | 99%    |
| 별이    | 마스터 | 98%    |
| 병석    | 아이언 | 1%     |



유저 아이디가 등급을 결정하고, 등급이 할인율을 결정하면 유저 아이디가 할인율을 결정할 수 있다.

* 유저 ID -> 등급, 등급 -> 할인율, 그렇다면 유저 ID -> 할인율



다음과 같이 분해한다.

| 유저 Id | 등급   | ---- | 등급   | 할인율 |
| ------- | ------ | ---- | ------ | ------ |
| 영수    | 챌린저 | ---- | 챌린저 | 99%    |
| 별이    | 마스터 | ---- | 마스터 | 98%    |
| 병석    | 아이언 | ---- | 아이언 | 1%     |

---

### BCNF 정규화(보이스-코드 정규화)

BCNF는 제 3정규형을 좀 더 강화한 버전으로 다음과 같은 규칙을 만족해야 한다.

> 1. 3정규형을 만족해야 한다.
> 2. 모든 결정자가 후보키 집합에 속해야 한다.
>
> > 모든 결정자가 후보키 집합에 속해야 한다는 뜻은, 후보키 집합에 없는 칼럼이 결정자가 되어서는 안 된다는 뜻이다.

| 학번  | 수강명     | 강사 |
| ----- | ---------- | ---- |
| 20201 | 코딩테스트 | 영수 |
| 20202 | 네트워크   | 별이 |
| 20203 | 코딩테스트 | 영수 |
| 20204 | 디자인패턴 | 응애 |



*  (학번, 수강명)이 기본키로 강사를 알 수 있다

*  같은 수강을 다른 강사가 가르칠 수도 있어서 수강명-> 강사 종속은 성립하지 않는다
*  하지만 강사가 어떤 수강을 가르치는지는 알 수 있으므로 강사-> 수강 종속이 성립한다.



이처럼 후보키 집합이 아닌 컬럼이 결정자가 되어버린 상황을 BCNF를 만족하지 않는다고 한다.   
즉 강사 속성이 결정자이지만 후보키가 아니므로 이 강사 속성을 분리해야 한다



| 학번  | 강사 | ----- | 수강명       | 강사   |
| ----- | ---- | ----- | ------------ | ------ |
| 20201 | 영수 | ----- | 코딩테스트   | 영수   |
| 20202 | 별이 | ----- | 네트워크     | 별이   |
| 20203 | 영수 | ----- | 디자인패턴   | 응애   |
| 20204 | 응애 | ----- | 타입스크립트 | 김타입 |



정규화를 걸쳐 테이블을 나눈다고 해서 성능이 100% 좋아지는 것은 아니다. 좋아질 수도 나빠질 수도 있다. 테이블을 나누는 경우 조인을 해야하는 경우도 발생해서 오히려 느려질 수도 있기 때문에 비정규화(반정규화)를 거칠수도 있다.

---

### 비정규화(반정규화)란?



**반정규화(De-normalization)**은 시스템의 성능 향상을 위해 정규화된 데이터 모델을 통합하는 작업으로, 의도적으로 정규화 원칙을 위배하는 행위이다. 따라서 정규화와 반정규화는 Trade-off 관계에 있다.    

 

* 반정규화의 종류로는 테이블 통합/분할/추가, 중복 속성 추가 등이 있다. 

* 반정규화를 수행하면 **테이블이 단순해지고 관리 효율성이 증가하지만, 데이터의 일관성이나 무결성이 보장되지 않을 수 있다**. 의도적으로 중복을 생성하여 검색 기능은 향상되지만, 갱신, 삭제 등의 성능은 낮아진다. 

* 따라서 데이터의 중복 방지, 무결성 vs 데이터베이스의 성능, 단순화 사이의 우선순위를 잘 조절하여 정규화/반정규화를 수행해야 한다. 

   


#### 반정규화의 대상이 되는 경우는 다음과 같다. 

 

1. 수행 속도가 많이 느린 경우 

2. 테이블의 조인(JOIN)연산을 지나치게 사용하여 데이터를 조회하는 것이 기술적으로 어려운 경우

3. 테이블에 많은 데이터가 있고, 다량의 범위 혹은 특정 범위를 자주 처리해야 하는 경우

